<!DOCTYPE html>
<meta charset="UTF-8">

<title>Modeling Machine And Human States To Enable And Evaluate Secure
Usability</title>

<style>
body {
  margin: 1in;
  width: 50em;
}
</style>

<h1>Modeling Machine And Human States To Enable And Evaluate Secure
Usability</h1>

<p>Chris Palmer, <a
href="mailto:chris@noncombatant.org">chris@noncombatant.org</a></p>

<h2>Abstract</h2>

<p>TODO</p>

<h2>Introduction</h2>

<p>We can describe or model much of a software program’s behavior as transitions
from 1 state to another. The same is true of protocols, ceremonies, and
computing hardware. In this paper, the generic term <em>machine</em> refers to
any software, hardware, protocol, or ceremony.</p>

<p>Good user experience (UX) engineering should help people to develop
accurate-enough mental models of the machine’s state. (See for example <a
href="http://www.nngroup.com/articles/mental-models/">“Mental Models” by Jakob
Nielsen</a>. TODO: Find better/more citations.) In order to do that, we need to
develop a model of the state transitions the <em>human</em> makes as well as
those the machine makes. We must also model the probability that the human’s
model accurately tracks that of the machine, where necessary. (It is rarely
necessary or possible for the human to track the machine’s state exactly.)</p>

<p>When the human cannot track the machine’s state, poor usability results. But,
some state tracking mismatches are also security vulnerabilities. TODO: Provide
an example; maybe hint at examples later in the paper.</p>

<p>TODO</p>

<h2>Prior Work</h2>

<p><a
href="http://projecteuclid.org/download/pdf_1/euclid.aoms/1177699147">Hidden
Markov models</a></p>

<p><a href="https://eprint.iacr.org/2007/399.pdf"><em>Ceremony Design And
Analysis</em></a> by Carl Ellison</p>

<p>TODO. Adrienne sent more good ones.</p>

<h2>Hello, World</h2>

<p>Consider the state transition diagram for the simplest possible UX control: A
button that sets a Boolean value in the program’s internal state. Assume it’s a
program variable to require (<var>true</var>) or not require (<var>false</var>)
that the program use only encrypted network communications.</p>

<div>
<img src="01-simple-boolean.png"/><br/>
<em>Figure 1: A simple Boolean option</em>
</div>

<p>To change states, the person performs a <em>gesture</em> (in this case,
clicks the button). With each click, the machine enters the 1 other possible
state; there are no other possible states. The machine changes state with
perfect certainty; there are no bugs in the <var>onclick</var> event handler. We
may presume that the person perceives the state change, both because they had to
perform an action to make it happen, and because the visual representation of
the button changes from <em>raised</em> to <em>pressed</em>.</p>

<p>UX designers and engineers know from painful experience that people do not,
in fact, always have perfect perception of the changes that happen in the
machine’s state, even with such ‘obvious’ causes as the person’s own click
gesture, and with such ‘obvious’ effects as the change in the visual appearance
of the button. For examples of why this might happen, consider:</p>

<ul>

<li>this might be the person’s first time using a computer</li>

<li>the graphic design of the UX elements may have changed since the last
software update, and the person has not yet learned the new appearance for
<em>raised</em> and <em>pressed</em> buttons</li>

<li>the person may not be sure if the machine recognized the gesture</li>

<li>the machine may not update the visual representation in time (“jank”) or
otherwise handle the event in real time</li>

</ul>

<p>There is a certain probability that the person is confused in 1 (or more) of
these ways. To start, we may assume that it is highly probable that the person’s
mental model can track the machine’s state model; assume that the probability of
correct tracking is 0.9. Further assume that the probability of incorrect
tracking is 0.1. In Figure 2, incorrect states are identified by square
vertices, and the edges are marked with their probabilities. Additionally, the
edges are shown in light gray for low probability, and in darker gray for high
probability.</p>

<div>
<img src="02-simple-boolean-with-confusion.png"/><br/>
<em>Figure 2: A simple Boolean option, allowing for human confusion</em>
</div>

<blockquote>TODO: Problem with Figures 2 and 3: the labels “click 1” and “click
2”, which I intend to link the 2 divergent outcomes from the same click, is kind
of a hack. Currently using subgraphs in the dot files to group the clicks. Not
sure how well it will work.</blockquote>

<p>Sometimes people can be confused about what states are even possible in the
machine’s state model. In this example, TODO:</p>

<div>
<img src="03-simple-boolean-with-orthogonal-states.png"/><br/>
<em>Figure 3: A simple Boolean option, allowing for human confusion as to what
states are even possible for the machine</em>
</div>

<p>TODO: the situation when the human’s model of the machine state model is
inaccurate or incomplete, both in ways that do not matter and in ways that
do</p>

<h2>Basic Constraints</h2>

<p>All edges out of a vertex must add up to p = 1.0. Except for the SAS, which
is like a bonus. TODO</p>

<h3>The Secure Attention Sequence</h3>

<p>A secure attention sequence is any gesture which</p>

<ul>

<li>the underlying platform interprets without passing the gesture through to
potentially untrustworthy, lower-privilege code</li>

<li>always causes the platform to run only code from its trusted computing
base</li>

<li>the trustworthy code always shows trustworthy (unforgeable,
un-eavesdroppable) UI</li>

</ul>

<p>Despite the name ‘sequence’, the gesture may be a simple one like pressing
<em>Escape</em> on the keyboard or the <em>Home</em> button on an iOS device.
The term ‘sequence’ may be a historical quirk: one of the first SASs was the
Windows and OS/2 SAS, the complex keyboard gesture
<em>Control-Alt-Delete</em>.</p>

<p>Possible example SASs:</p>

<ul>

<li>Control-Alt-Delete on Windows (the GINA/modern equivalent TODO runs in its
own desktop and as its own principal)</li>

<li>The Home button on iOS devices</li>

<li>Anything on Chrome OS?</li>

</ul>

<p>Requirements for SAS:</p>

<ul>

<li>all edges must point to the same vertex</li>

<li>every other vertex (or at least every machine state (circle) vertex) must
have a SAS edge</li>

</ul>

<h2>Example: Full Screen Mode</h2>

<p>TODO</p>

<h2>Example: Origin Security Indicators</h2>

<p>TODO</p>

<h2>Acknowledgements</h2>

<p>I’d like to thank the Academy, and Jesus.</p>

<!--

TODO and writing style guidelines:

* Avoid saying ‘user’
* Avoid the passive voice
* Prefer verb phrases to gerunds

-->
